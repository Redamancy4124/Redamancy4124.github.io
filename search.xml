<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day01</title>
    <url>/2023/05/04/Day/</url>
    <content><![CDATA[<h2 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h2><h5 id="初识Vue："><a href="#初识Vue：" class="headerlink" title="初识Vue："></a>初识Vue：</h5><p>​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p>
<p>​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p>
<p>​        3.root容器里的代码被称为<strong>【Vue模板】；</strong></p>
<p>​        <strong>4.Vue实例和容器是一一对应的；</strong></p>
<p>​        5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p>
<p>​        6.中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p>
<p>​        7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<p>​        注意区分：js表达式 和 js代码(语句)</p>
<p>​            1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：</p>
<p>​                  (1). a</p>
<p>​                  (2). a+b</p>
<p>​                  (3). demo(1)</p>
<p>​                  (4). x &#x3D;&#x3D;&#x3D; y ? ‘a’ : ‘b’</p>
<p>​            2.js代码(语句)</p>
<p>​                  (1). if(){}</p>
<p>​                  (2). for(){}</p>
<h5 id="Vue模板语法有2大类："><a href="#Vue模板语法有2大类：" class="headerlink" title="Vue模板语法有2大类："></a>Vue模板语法有2大类：</h5><h6 id="1-插值语法："><a href="#1-插值语法：" class="headerlink" title="1.插值语法："></a><strong>1.插值语法：</strong></h6><p>​              功能：用于解析标签体内容。</p>
<p>​              写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<h6 id="2-指令语法："><a href="#2-指令语法：" class="headerlink" title="2.指令语法："></a><strong>2.指令语法：</strong></h6><p>​             <em>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</em></p>
<p>​              举例：v-bind:href&#x3D;”xxx” 或  简写为 :href&#x3D;”xxx”，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>​              备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Day02</title>
    <url>/2023/05/06/Day02/</url>
    <content><![CDATA[<h5 id="Vue中有2种数据绑定的方式："><a href="#Vue中有2种数据绑定的方式：" class="headerlink" title="Vue中有2种数据绑定的方式："></a>Vue中有2种数据绑定的方式：</h5><p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h5 id="data与el的2种写法"><a href="#data与el的2种写法" class="headerlink" title="data与el的2种写法"></a>data与el的2种写法</h5><p>​          1.el有2种写法</p>
<p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p>
<p>​          2.data有2种写法</p>
<p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<p>​          3.一个重要的原则：</p>
<p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
<h5 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h5><p>​            1. M：模型(Model) ：data中的数据</p>
<p>​            2. V：视图(View) ：模板代码</p>
<p>​            3. VM：视图模型(ViewModel)：Vue实例</p>
<p>​     <em>观察发现：</em></p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h5 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h5><!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）-->

<p>![](E:\Desktop Folder\尚硅谷\imags\数据代理.png)</p>
<p> 1.Vue中的数据代理：</p>
<p>​              通过vm对象来代理data对象中属性的操作（读&#x2F;写）</p>
<p>​        2.Vue中数据代理的好处：</p>
<p>​              更加方便的操作data中的数据</p>
<p>​        &#x3D;&#x3D;3.基本原理&#x3D;&#x3D;：</p>
<p>​              <strong>通过Object.defineProperty()把data对象中所有属性添加到vm上。</strong></p>
<p>​              <strong>为每一个添加到vm上的属性，都指定一个getter&#x2F;setter。</strong></p>
<p>​              <strong>在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性</strong>。</p>
<h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><h6 id="事件的基本使用："><a href="#事件的基本使用：" class="headerlink" title="事件的基本使用："></a>事件的基本使用：</h6><p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p>
<p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p>
<p>​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p>
<p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p>
<p>​              5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参；</p>
<h6 id="Vue中的事件修饰符："><a href="#Vue中的事件修饰符：" class="headerlink" title="Vue中的事件修饰符："></a>Vue中的事件修饰符：</h6><p>​            1.prevent：阻止默认事件（常用）；</p>
<p>​            2.stop：阻止事件冒泡（常用）；</p>
<p>​            3.once：事件只触发一次（常用）；</p>
<p>​            4.capture：使用事件的捕获模式；</p>
<p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p>
<p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>数据绑定</tag>
        <tag>数据代理</tag>
        <tag>MVVM模型</tag>
        <tag>事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Day03（计算属性、监视属性watch）</title>
    <url>/2023/05/04/Day03%EF%BC%88%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Day03（计算属性、监视属性watch）"><a href="#Day03（计算属性、监视属性watch）" class="headerlink" title="Day03（计算属性、监视属性watch）"></a>Day03（计算属性、监视属性watch）</h2><h5 id="1-Vue中常用的按键别名："><a href="#1-Vue中常用的按键别名：" class="headerlink" title="1.Vue中常用的按键别名："></a>1.Vue中常用的按键别名：</h5><p>​              回车 &#x3D;&gt; enter</p>
<p>​              删除 &#x3D;&gt; delete (捕获“删除”和“退格”键)</p>
<p>​              退出 &#x3D;&gt; esc</p>
<p>​              空格 &#x3D;&gt; space</p>
<p>​              换行 &#x3D;&gt; tab (特殊，必须配合keydown去使用)</p>
<p>​              上 &#x3D;&gt; up</p>
<p>​              下 &#x3D;&gt; down</p>
<p>​              左 &#x3D;&gt; left</p>
<p>​              右 &#x3D;&gt; right</p>
<p>​        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>​        3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<p>​              (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p>
<p>​              (2).配合keydown使用：正常触发事件。</p>
<p>​        4.也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>​        5.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名</p>
<h5 id="计算属性："><a href="#计算属性：" class="headerlink" title="计算属性："></a>计算属性：</h5><p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p>
<p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p>
<p>​          3.get函数什么时候执行？</p>
<p>​                (1).初次读取时会执行一次。</p>
<p>​                (2).当依赖的数据发生改变时会被再次调用。</p>
<p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p>
<p>​          5.备注：</p>
<p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p>
<p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p>
<h5 id="监视属性watch："><a href="#监视属性watch：" class="headerlink" title="监视属性watch："></a>监视属性watch：</h5><p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
<p>​          2.监视的属性必须存在，才能进行监视！！</p>
<p>​          3.监视的两种写法：</p>
<p>​              (1).new Vue时传入watch配置</p>
<p>​              (2).通过vm.$watch监视</p>
<h5 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h5><p>​            (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p>
<p>​            (2).配置deep:true可以监测对象内部值改变（多层）。</p>
<p>​        备注：</p>
<p>​            (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p>
<p>​            (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p>
<h5 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h5><p>​            1.computed能完成的功能，watch都可以完成。</p>
<p>​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p>​        两个重要的小原则：</p>
<p>​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</p>
<p>​                这样this的指向才是vm 或 组件实例对象。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
        <tag>计算属性</tag>
        <tag>监视属性watch</tag>
      </tags>
  </entry>
  <entry>
    <title>样式绑定、条件渲染</title>
    <url>/2023/05/04/Day04%EF%BC%88%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A%E3%80%81%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Day04（样式绑定、条件渲染）"><a href="#Day04（样式绑定、条件渲染）" class="headerlink" title="Day04（样式绑定、条件渲染）"></a>Day04（样式绑定、条件渲染）</h2><h5 id="绑定样式："><a href="#绑定样式：" class="headerlink" title="绑定样式："></a>绑定样式：</h5><h6 id="1-class样式"><a href="#1-class样式" class="headerlink" title="1. class样式"></a>1. class样式</h6><p>​                写法:class&#x3D;”xxx” xxx可以是字符串、对象、数组。</p>
<p>​                    字符串写法适用于：类名不确定，要动态获取。</p>
<p>​                    对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p>​                    数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<h6 id="2-style样式"><a href="#2-style样式" class="headerlink" title="2. style样式"></a>2. style样式</h6><p>​                :style&#x3D;”{fontSize: xxx}”其中xxx是动态值。</p>
<p>​                :style&#x3D;”[a,b]”其中a、b是样式对象。</p>
<h5 id="条件渲染："><a href="#条件渲染：" class="headerlink" title="条件渲染："></a>条件渲染：</h5><h6 id="1-v-if"><a href="#1-v-if" class="headerlink" title="1.v-if"></a>1.v-if</h6><p>​                    写法：</p>
<p>​                        (1).v-if&#x3D;”表达式” </p>
<p>​                        (2).v-else-if&#x3D;”表达式”</p>
<p>​                        (3).v-else&#x3D;”表达式”</p>
<p>​                    适用于：切换频率较低的场景。</p>
<p>​                    特点：不展示的DOM元素直接被移除。</p>
<p>​                    注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<h6 id="2-v-show"><a href="#2-v-show" class="headerlink" title="2.v-show"></a>2.v-show</h6><p>​                    写法：v-show&#x3D;”表达式”</p>
<p>​                    适用于：切换频率较高的场景。</p>
<p>​                    特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>​                </p>
<h6 id="3-备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。"><a href="#3-备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。" class="headerlink" title="3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。"></a>3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</h6><h5 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令:"></a>v-for指令:</h5><p>​            1.用于展示列表数据</p>
<p>​            2.语法：v-for&#x3D;”(item, index) in xxx” :key&#x3D;”yyy”</p>
<p>​            3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
        <tag>样式绑定</tag>
        <tag>条件渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2023/05/15/Vuex/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">//应用Vuex插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-comment">//准备actions对象——响应组件中用户的动作</span><br><span class="hljs-keyword">const</span> actions = &#123;&#125;<br><span class="hljs-comment">//准备mutations对象——修改state中的数据</span><br><span class="hljs-keyword">const</span> mutations = &#123;&#125;<br><span class="hljs-comment">//准备state对象——保存具体的数据</span><br><span class="hljs-keyword">const</span> state = &#123;&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>	actions,<br>	mutations,<br>	state<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">......<br><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br>......<br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>	<span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>	<span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>	store<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">//引用Vuex</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-comment">//响应组件中加的动作</span><br>	<span class="hljs-title function_">jia</span>(<span class="hljs-params">context,value</span>)&#123;<br>		<span class="hljs-comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span><br>		context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;JIA&#x27;</span>,value)<br>	&#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>    <span class="hljs-comment">//执行加</span><br>	<span class="hljs-title function_">JIA</span>(<span class="hljs-params">state,value</span>)&#123;<br>		<span class="hljs-comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span><br>		state.<span class="hljs-property">sum</span> += value<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//初始化数据</span><br><span class="hljs-keyword">const</span> state = &#123;<br>   <span class="hljs-attr">sum</span>:<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>	actions,<br>	mutations,<br>	state,<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">......<br><br><span class="hljs-keyword">const</span> getters = &#123;<br>	<span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br>		<span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>	......<br>	getters<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span><br>     ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-attr">subject</span>:<span class="hljs-string">&#x27;subject&#x27;</span>&#125;),<br>         <br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>&#125;,<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>(&#123;<span class="hljs-attr">bigSum</span>:<span class="hljs-string">&#x27;bigSum&#x27;</span>&#125;),<br><br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br><br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-string">&#x27;jiaWait&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：increment、decrement（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>    <br>    <span class="hljs-comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-string">&#x27;JIAN&#x27;</span>]),<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>&#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> personAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123; ... &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    countAbout,<br>    personAbout<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">personAbout</span>.<span class="hljs-property">list</span><br><span class="hljs-comment">//方式二：借助mapState读取：</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br><span class="hljs-comment">//方式二：借助mapGetters读取：</span><br>...<span class="hljs-title function_">mapGetters</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接dispatch</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapActions：</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接commit</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapMutations：</span><br>...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue监视数据的原理</title>
    <url>/2023/05/15/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<h2 id="Vue监视数据的原理："><a href="#Vue监视数据的原理：" class="headerlink" title="Vue监视数据的原理："></a>Vue监视数据的原理：</h2><h5 id="1-vue会监视data中所有层次的数据。"><a href="#1-vue会监视data中所有层次的数据。" class="headerlink" title="1. vue会监视data中所有层次的数据。"></a>1. vue会监视data中所有层次的数据。</h5><h5 id="2-如何监测对象中的数据？"><a href="#2-如何监测对象中的数据？" class="headerlink" title="2. 如何监测对象中的数据？"></a>2. 如何监测对象中的数据？</h5><p>​                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<h6 id="1-对象中后追加的属性，Vue默认不做响应式处理"><a href="#1-对象中后追加的属性，Vue默认不做响应式处理" class="headerlink" title="(1).对象中后追加的属性，Vue默认不做响应式处理"></a>(1).对象中后追加的属性，Vue默认不做响应式处理</h6><h6 id="2-如需给后添加的属性做响应式，请使用如下API："><a href="#2-如需给后添加的属性做响应式，请使用如下API：" class="headerlink" title="(2).如需给后添加的属性做响应式，请使用如下API："></a>(2).如需给后添加的属性做响应式，请使用如下API：</h6><p>​                          Vue.set(target，propertyName&#x2F;index，value) 或 </p>
<p>​                          vm.$set(target，propertyName&#x2F;index，value)</p>
<h5 id="3-如何监测数组中的数据？"><a href="#3-如何监测数组中的数据？" class="headerlink" title="3. 如何监测数组中的数据？"></a>3. 如何监测数组中的数据？</h5><p>​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<h6 id="1-调用原生对应的方法对数组进行更新。"><a href="#1-调用原生对应的方法对数组进行更新。" class="headerlink" title="(1).调用原生对应的方法对数组进行更新。"></a>(1).调用原生对应的方法对数组进行更新。</h6><h6 id="2-重新解析模板，进而更新页面。"><a href="#2-重新解析模板，进而更新页面。" class="headerlink" title="(2).重新解析模板，进而更新页面。"></a>(2).重新解析模板，进而更新页面。</h6><h5 id="4-在Vue修改数组中的某个元素一定要用如下方法："><a href="#4-在Vue修改数组中的某个元素一定要用如下方法：" class="headerlink" title="4.在Vue修改数组中的某个元素一定要用如下方法："></a>4.在Vue修改数组中的某个元素一定要用如下方法：</h5><p>​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p>
<p>​              2.Vue.set() 或 vm.$set()</p>
<p>​        </p>
<p>​        特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2023/05/02/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1-什么是重绘和重排"><a href="#1-什么是重绘和重排" class="headerlink" title="1.什么是重绘和重排"></a>1.什么是重绘和重排</h5><p>重绘：当页面元素的样式改变不影响布局时，浏览器重新对元素 进行更新的过程叫做重绘。 </p>
<p>重排：当页面元素的尺寸、结构、或某些属性发生改变时，浏览 器重新渲染部分或全部文档的过程叫做重排也叫做回流。</p>
<h5 id="2-this理解"><a href="#2-this理解" class="headerlink" title="2.this理解"></a>2.this理解</h5><p>箭头函数内不存在this，沿用上一级的，上一级没有继续往上 找，直到找到有this的地方 this是函数调用的时候确定的。不是定义时候确定的 对象的方法内部, 看方法被谁调用</p>
<h5 id="3-改变this有哪些方法-箭头函数特点"><a href="#3-改变this有哪些方法-箭头函数特点" class="headerlink" title="3.改变this有哪些方法-箭头函数特点"></a>3.改变this有哪些方法-箭头函数特点</h5><p>箭头函数 call（） apply（） bind（）</p>
<h5 id="4-原型的理解"><a href="#4-原型的理解" class="headerlink" title="4.原型的理解"></a>4.原型的理解</h5><p> 每一个构造函数都有一个 prototype 属性，指向另一个对象，所 以我们也称为原型对象 </p>
<ul>
<li><h5 id="5-原型链的理解"><a href="#5-原型链的理解" class="headerlink" title="5.原型链的理解"></a>5.原型链的理解</h5><ul>
<li>_proto_对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</li>
</ul>
</li>
<li><h5 id="6-es6-新增哪些内容"><a href="#6-es6-新增哪些内容" class="headerlink" title="6.es6 新增哪些内容"></a>6.es6 新增哪些内容</h5><ul>
<li><p>let const</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>对象&#x2F;数组解构</p>
</li>
<li><p>ES6模块化开发</p>
</li>
<li><p>Set   和   map数据结构</p>
</li>
<li><p>Promise</p>
</li>
<li><p>扩展运算符</p>
</li>
<li><p>模板字符串</p>
</li>
<li><p>async await</p>
</li>
</ul>
</li>
<li><h5 id="7-let-const-区别"><a href="#7-let-const-区别" class="headerlink" title="7.*let const 区别  *"></a>7.*let const 区别  *</h5><ul>
<li><p>let可以声明变量不赋值，const声明时必须赋值</p>
</li>
<li><p>let定义的变量可以修改，const声明的变量不可以修改</p>
</li>
</ul>
</li>
<li><h5 id="8-cookie-、本地存储、session的区别"><a href="#8-cookie-、本地存储、session的区别" class="headerlink" title="8.cookie 、本地存储、session的区别"></a>8.cookie 、本地存储、session的区别</h5><ul>
<li><p>1 存储大小不同</p>
<ul>
<li><p>cookie： 4K</p>
</li>
<li><p>session : 5M</p>
</li>
<li><p>local：5M</p>
</li>
</ul>
</li>
<li><p>2 数据有效期不同，</p>
<ul>
<li><p>cookie可以设置， 设置过期时间， 也可以手动清空</p>
</li>
<li><p>session：仅在浏览器关闭前有效</p>
</li>
<li><p>local：永久有效，除非手动清除</p>
</li>
</ul>
</li>
<li><p>3 作用域，</p>
<ul>
<li><p>cookie在所有同源窗口共享</p>
</li>
<li><p>session仅在一个浏览器共享，不同浏览器不共享</p>
</li>
<li><p>local在所有同源窗口共享</p>
</li>
</ul>
</li>
<li><p>4 通信，</p>
<ul>
<li><p>cookie: 通过http,在浏览器和服务器传递</p>
</li>
<li><p>session仅在客户端</p>
</li>
<li><p>local仅在客户端</p>
</li>
</ul>
</li>
<li><p>5 应用，</p>
<ul>
<li><p>cookie判断用户是否登陆过，记忆密码自动登录</p>
</li>
<li><p>session敏感账号一次登录，关闭浏览器删除</p>
</li>
<li><p>local个人长期登录， 长期保存数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="9-堆和栈的理解"><a href="#9-堆和栈的理解" class="headerlink" title="9.堆和栈的理解"></a>9.堆和栈的理解</h5><ul>
<li><p>栈： 简单数据类型存放到栈里面，由操作系统自动分配释放存放函数的参数值、局部变量的值等。</p>
</li>
<li><p>堆：存储复杂类型对象，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
</li>
</ul>
</li>
<li><h5 id="10-基础和复杂-的区别"><a href="#10-基础和复杂-的区别" class="headerlink" title="10.基础和复杂 的区别"></a>10.基础和复杂 的区别</h5><ul>
<li><p>存储上的区别</p>
<ul>
<li><p>基本数据类型，直接存储在   栈   里</p>
</li>
<li><p>复杂数据类型，数据存储在   堆   里，把地址存储在   栈   里</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="11-深拷贝和浅拷贝的区别，怎么做一个深拷贝-和浅拷贝"><a href="#11-深拷贝和浅拷贝的区别，怎么做一个深拷贝-和浅拷贝" class="headerlink" title="11.深拷贝和浅拷贝的区别，怎么做一个深拷贝 和浅拷贝"></a>11.深拷贝和浅拷贝的区别，怎么做一个深拷贝 和浅拷贝</h5><ul>
<li><p>浅拷贝是 遍历拷贝对象第一层属性名和属性值</p>
</li>
<li><p>深拷贝是遍历拷贝一个对象第一层属性名和属性值，如果发现属性值是一个对象，则递归拷贝所有深层的属性</p>
</li>
</ul>
</li>
<li><h5 id="12-vue2底层-数据拦截-的用什么实现的？有什么缺点？-或者叫响应式的原理-vue3实现有什么不同"><a href="#12-vue2底层-数据拦截-的用什么实现的？有什么缺点？-或者叫响应式的原理-vue3实现有什么不同" class="headerlink" title="12.vue2底层 数据拦截 的用什么实现的？有什么缺点？  (或者叫响应式的原理),vue3实现有什么不同"></a>12.vue2底层 数据拦截 的用什么实现的？有什么缺点？  (或者叫响应式的原理),vue3实现有什么不同</h5><ul>
<li><p>vue2</p>
<ul>
<li><p>vue2   使用了defineproperty   监听对象属性的变化</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>不能监听通过下标给数组添加元素（调用splice修改或者调用强制更新）</p>
</li>
<li><p>要定义的数据必须要提前在data中定义好</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>vue3</p>
<ul>
<li><p>使用了es6新增的Proxy来监听对象属性的变化</p>
</li>
<li><p>优点</p>
<ul>
<li>解决可以监听数组的方法，能通过下标修改数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="13-闭包的理解，什么是闭包"><a href="#13-闭包的理解，什么是闭包" class="headerlink" title="13.闭包的理解，什么是闭包"></a>13.闭包的理解，什么是闭包</h5><ul>
<li><p>简单理解：闭包 &#x3D; 内层函数 + 外层函数的变量</p>
</li>
<li><p>闭包是一个 函数的执行空间,执行空间有一个局部变量被外部引用，这个执行空间就是闭包</p>
</li>
</ul>
</li>
<li><h5 id="14-闭包使用场景"><a href="#14-闭包使用场景" class="headerlink" title="14.闭包使用场景"></a>14.闭包使用场景</h5><ul>
<li><p>实现数据的私有</p>
</li>
<li><p>函数柯理化</p>
</li>
</ul>
</li>
<li><h5 id="15-闭包缺点"><a href="#15-闭包缺点" class="headerlink" title="15.闭包缺点"></a>15.闭包缺点</h5><ul>
<li>造成内存泄漏</li>
</ul>
</li>
<li><h5 id="16-作用域链"><a href="#16-作用域链" class="headerlink" title="16.作用域链"></a>16.作用域链</h5><ul>
<li><p>作用域链本质上是底层的变量查找机制</p>
</li>
<li><p>在函数被执行时，会优先查找当前函数作用域中查找变量</p>
</li>
<li><p>如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域</p>
</li>
</ul>
</li>
<li><h5 id="17-垃圾回收机制"><a href="#17-垃圾回收机制" class="headerlink" title="17.垃圾回收机制"></a>17.垃圾回收机制</h5><ul>
<li><p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收</p>
</li>
<li><p>两种回收算法</p>
<ul>
<li><p>引用计数法</p>
</li>
<li><p>标记清除法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="18-防抖和节流"><a href="#18-防抖和节流" class="headerlink" title="18.防抖和节流"></a>18.防抖和节流</h5><ul>
<li><p>防抖:如果在 n 秒内又触发了事件，则会重新计算函数执行时间</p>
</li>
<li><p>节流: 就是指连续触发事件但是在 n 秒中只执行一次函数</p>
</li>
</ul>
</li>
<li><h5 id="19-应用场景"><a href="#19-应用场景" class="headerlink" title="19.应用场景"></a>19.应用场景</h5><ul>
<li><p>防抖使用场景：   搜索框输入，设定每次输入完毕n秒后发送请求，如果期间还有输入，则从新计算时间</p>
</li>
<li><p>节流使用场景：   : 鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较大的情况下</p>
</li>
</ul>
</li>
<li><h5 id="20-hash和history的区别"><a href="#20-hash和history的区别" class="headerlink" title="20.hash和history的区别"></a>20.hash和history的区别</h5><ul>
<li><p>一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽</p>
</li>
<li><p>底层实现不一样：（背过）</p>
<ul>
<li><p>hash 路由使用 利用url 的hash值变化实现，</p>
</li>
<li><p>history路由使用 h5新增的 history.pushState API 实现（需要服务器配合-如果服务器不配置，刷新就会404）</p>
</li>
</ul>
</li>
<li><p>其他考虑</p>
<ul>
<li><p>1.形式上：hash模式url里面永远带着#号，开发当中默认使用这个模式。如果用户考虑url的规范那么就需要使用history模式，因为history模式没有#号，是个正常的url，适合推广宣传；</p>
</li>
<li><p>2.功能上：比如我们在开发app的时候有分享页面，那么这个分享出去的页面就是用vue或是react做的，咱们把这个页面分享到第三方的app里，有的app里面url是不允许带有#号的，所以要将#号去除那么就要使用history模式，但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，那么就需要和后端人配合，让他配置一下apache或是nginx的url重定向，重定向到你的首页路由上就ok了</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="21-Promise"><a href="#21-Promise" class="headerlink" title="21.Promise"></a>21.Promise</h5><ul>
<li><img src="https://api2.mubu.com/v3/document_image/429e2f8c-a180-468c-9f2e-09dc85396103-15762273.jpg" alt="img"></li>
</ul>
</li>
<li><h5 id="22-async和await"><a href="#22-async和await" class="headerlink" title="22.async和await"></a>22.async和await</h5><ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/35b896e9-f263-433d-a056-564f76ff664f-15762273.jpg" alt="img"></p>
</li>
<li><p>不能等失败，配合try-catch</p>
</li>
</ul>
</li>
<li><h5 id="23-跨域的解决方案"><a href="#23-跨域的解决方案" class="headerlink" title="23.跨域的解决方案"></a>23.跨域的解决方案</h5><ul>
<li><p>1.cors-跨域资源共享（跟前端没有关系）</p>
</li>
<li><p>2-代理服务器</p>
</li>
<li><p>3-代理插件（proxyServer）</p>
</li>
<li><p>前端的使用vue或者react开发的时候，项目也可以安装一个代理插件</p>
</li>
<li><p>注意：只能是开发中使用，项目上线是用不了的</p>
</li>
<li><p>4-websocket（socket 协议）</p>
</li>
<li><p>使用不是http协议，没有跨域问题，socket 协议</p>
</li>
<li><p>区别：</p>
<ul>
<li><p>http协议是单向的，只能浏览器发送给服务器</p>
</li>
<li><p>socket 是双向的，例如：微信聊天</p>
</li>
</ul>
</li>
<li><p>5-jsonp</p>
</li>
</ul>
</li>
<li><h5 id="24-jsonp-常见的面试题"><a href="#24-jsonp-常见的面试题" class="headerlink" title="24.jsonp 常见的面试题"></a>24.jsonp 常见的面试题</h5><ul>
<li><p>1.jsonp 原理</p>
<ul>
<li><p>src 不受同源策略影响</p>
</li>
<li><p>script 标签会把请求的内容当作 js 代码来执行</p>
</li>
</ul>
</li>
<li><p>2.jsonp 的返回值</p>
<ul>
<li><p>字符串，函数名() 形式的字符串</p>
</li>
<li><p>一段可以执行的 js 代码字符串</p>
</li>
</ul>
</li>
<li><p>3.jsonp 的优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>绕开了同源策略，实现跨城请求</p>
</li>
<li><p>方便，因为是以 script 标签外部资源的形式请求</p>
</li>
</ul>
</li>
<li><p>缺点：不好做安全防范</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="25-ajax-axios-fetch-的区别"><a href="#25-ajax-axios-fetch-的区别" class="headerlink" title="25.ajax axios fetch 的区别"></a>25.ajax axios fetch 的区别</h5><ul>
<li><p>axios -基于promsie封装的ajax</p>
</li>
<li><p>fetch -新的网络请求api js中提供的最新的请求api，提供promise的api（原生js中api）</p>
</li>
<li><p>Fetch 是一个 API，它是真实存在的，它是基于 promise 的。</p>
</li>
<li><p>ajax -底层 使用 XMLHttpRequest</p>
</li>
</ul>
</li>
<li><h5 id="26-什么是token"><a href="#26-什么是token" class="headerlink" title="26.什么是token"></a>26.什么是token</h5><ul>
<li>token 是服务器端生成的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>，以作客户端进行请求的一个令牌，当第一次登陆后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token请求数据即可，无需再次带上用户名和密码。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题：react、vue中的key有什么作用？（key的内部原理）</title>
    <url>/2023/05/04/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areact%E3%80%81vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面试题：react、vue中的key有什么作用？（key的内部原理）"><a href="#面试题：react、vue中的key有什么作用？（key的内部原理）" class="headerlink" title="面试题：react、vue中的key有什么作用？（key的内部原理）"></a>面试题：react、vue中的key有什么作用？（key的内部原理）</h2><h5 id="1-虚拟DOM中key的作用："><a href="#1-虚拟DOM中key的作用：" class="headerlink" title="1.虚拟DOM中key的作用："></a>1.虚拟DOM中key的作用：</h5><p>变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<h5 id="2-对比规则："><a href="#2-对比规则：" class="headerlink" title="2.对比规则："></a>2.对比规则：</h5><h6 id="1-旧虚拟DOM中找到了与新虚拟DOM相同的key："><a href="#1-旧虚拟DOM中找到了与新虚拟DOM相同的key：" class="headerlink" title="(1).旧虚拟DOM中找到了与新虚拟DOM相同的key："></a>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</h6><p>​                           ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>​                           ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<h6 id="2-旧虚拟DOM中未找到与新虚拟DOM相同的key"><a href="#2-旧虚拟DOM中未找到与新虚拟DOM相同的key" class="headerlink" title="(2).旧虚拟DOM中未找到与新虚拟DOM相同的key"></a>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key</h6><p>​                             创建新的真实DOM，随后渲染到到页面。<br>​                                                </p>
<h5 id="3-用index作为key可能会引发的问题："><a href="#3-用index作为key可能会引发的问题：" class="headerlink" title="3.用index作为key可能会引发的问题："></a>3.用index作为key可能会引发的问题：</h5><p>​	破坏顺序操作:<br>​	会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<p>​	如果结构中还包含输入类的DOM：<br>​    会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<h5 id="4-开发中如何选择key"><a href="#4-开发中如何选择key" class="headerlink" title="4.开发中如何选择key?:"></a>4.开发中如何选择key?:</h5><p>1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>使用index作为key是没有问题的。</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>Vue</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
